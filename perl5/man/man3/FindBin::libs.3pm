.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FindBin::libs 3"
.TH FindBin::libs 3 "2012-08-13" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
FindBin::libs \- locate and a 'use lib' or export 
directories based on $FindBin::Bin.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This version of FindBin::libs is suitable for 
Perl v5.10+.
.PP
.Vb 2
\&    # search up $FindBin::Bin looking for ./lib directories
\&    # and "use lib" them.
\&
\&    use FindBin::libs;
\&
\&    # same as above with explicit defaults.
\&
\&    use FindBin::libs qw( base=lib use=1 noexport noprint );
\&
\&    # print the lib dir\*(Aqs before using them.
\&
\&    use FindBin::libs qw( print );
\&
\&    # find and use lib "altlib" dir\*(Aqs
\&
\&    use FindBin::libs qw( base=altlib );
\&
\&    # move starting point from $FindBin::Bin to \*(Aq/tmp\*(Aq
\&
\&    use FindBin::libs qw( Bin=/tmp base=altlib );
\&
\&    # skip "use lib", export "@altlib" instead.
\&
\&    use FindBin::libs qw( base=altlib export );
\&
\&    # find altlib directories, use lib them and export @mylibs
\&
\&    use FindBin::libs qw( base=altlib export=mylibs use );
\&
\&    # "export" defaults to "nouse", these two are identical:
\&
\&    use FindBin::libs qw( export nouse );
\&    use FindBin::libs qw( export       );
\&
\&    # use and export are not exclusive:
\&
\&    use FindBin::libs qw( use export            ); # do both
\&    use FindBin::libs qw( nouse noexport print  ); # print only
\&    use FindBin::libs qw( nouse noexport        ); # do nothting at all
\&
\&    # print a few interesting messages about the 
\&    # items found.
\&
\&    use FindBinlibs qw( verbose );
\&
\&    # turn on a breakpoint after the args are prcoessed, before
\&    # any search/export/use lib is handled.
\&
\&    use FindBin::libs qw( debug );
\&
\&    # prefix PERL5LIB with the lib\*(Aqs found.
\&
\&    use FindBin::libs qw( perl5lib );
\&
\&    # find a subdir of the lib\*(Aqs looked for.
\&    # the first example will use both ../lib and
\&    # ../lib/perl5; the second ../lib/perl5/frobnicate
\&    # (if they exist). it can also be used with export
\&    # and base to locate special configuration dir\*(Aqs.
\&    #
\&    # subonly with a base is useful for locating config
\&    # files. this finds any "./config/mypackage" dir\*(Aqs
\&    # without including any ./config dir\*(Aqs. the result
\&    # ends up in @config (see also "export=", above).
\&
\&    use FindBin::libs qw( subdir=perl5 );
\&
\&    use FindBin::libs qw( subdir=perl5/frobnicate );
\&
\&    use FindBin::libs qw( base=config subdir=mypackage subonly export );
\&
\&    # base and subonly are also useful if your 
\&    # project is stored in multiple git 
\&    # repositories. 
\&    #
\&    # say you need libs under api_foo/lib from api_bar: a
\&    # base of the git repository directory with subdir of
\&    # lib and subonly will pull in those lib dirs.
\&
\&    use FindBin::libs qw( base=api_foo subdir=lib subonly );
\&
\&    # no harm in using this multiple times to use
\&    # or export multple layers of libs.
\&
\&    use FindBin::libs qw( export                                            );
\&    use FindBin::libs qw( export=found base=lib                             );
\&    use FindBin::libs qw( export=binz  base=bin            ignore=/foo,/bar );
\&    use FindBin::libs qw( export=junk  base=frobnicatorium                  );
\&    use FindBin::libs qw( export       base=foobar                          );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "General Use"
.IX Subsection "General Use"
This module will locate directories along the path to \f(CW$FindBin::Bin\fR
and \*(L"use lib\*(R" or export an array of the directories found. The default
is to locate \*(L"lib\*(R" directories and \*(L"use lib\*(R" them without printing
the list.
.PP
Options controll whether the lib's found are exported into the caller's
space, exported to \s-1PERL5LIB\s0, or printed. Exporting or setting perl5lib
will turn off the default of \*(L"use lib\*(R" so that:
.PP
.Vb 2
\&    use FindBin::libs qw( export );
\&    use FindBin::libs qw( p5lib  );
.Ve
.PP
are equivalent to
.PP
.Vb 2
\&    use FindBin::libs qw( export nouse );
\&    use FindBin::libs qw( p5lib  nouse );
.Ve
.PP
Combining export with use or p5lib may be useful, p5lib and
use are probably not all that useful together.
.PP
\fIAlternate directory name: 'base'\fR
.IX Subsection "Alternate directory name: 'base'"
.PP
The basename searched for can be changed via 'base=name' so
that
.PP
.Vb 1
\&    use FindBin::libs qw( base=altlib );
.Ve
.PP
will search for directories named \*(L"altlib\*(R" and \*(L"use lib\*(R" them.
.PP
\fIExporting a variable: 'export'\fR
.IX Subsection "Exporting a variable: 'export'"
.PP
The 'export' option will push an array of the directories found
and takes an optional argument of the array name, which defaults 
to the basename searched for:
.PP
.Vb 1
\&    use FindBin::libs qw( export );
.Ve
.PP
will find \*(L"lib\*(R" directories and export \f(CW@lib\fR with the
list of directories found.
.PP
.Vb 1
\&    use FindBin::libs qw( export=mylibs );
.Ve
.PP
will find \*(L"lib\*(R" directories and export them as \*(L"@mylibs\*(R" to
the caller.
.PP
If \*(L"export\*(R" only is given then the \*(L"use\*(R" option defaults to 
false. So:
.PP
.Vb 2
\&    use FindBin::libs qw( export );
\&    use FindBin::libs qw( export nouse );
.Ve
.PP
are equivalent. This is mainly for use when looking for data
directories with the \*(L"base=\*(R" argument.
.PP
If base is used with export the default array name is the base
directory value:
.PP
.Vb 1
\&    use FindBin::libs qw( export base=meta );
.Ve
.PP
exports \f(CW@meta\fR while
.PP
.Vb 1
\&    use FindBin::libs qw( export=metadirs base=meta );
.Ve
.PP
exports \f(CW@metadirs\fR.
.PP
The use and export switches are not exclusive:
.PP
.Vb 1
\&    use FindBin::libs qw( use export=mylibs );
.Ve
.PP
will locate \*(L"lib\*(R" directories, use lib them, and export 
\&\f(CW@mylibs\fR into the caller's package.
.PP
\fISubdirectories\fR
.IX Subsection "Subdirectories"
.PP
The \*(L"subdir\*(R" and \*(L"subonly\*(R" settings will add or 
exclusively use subdir's. This is useful if some
of your lib's are in ../lib/perl5 along with 
\&../lib (subdir=perl5) or all of the lib's are 
in ../lib/perl5 (subonly=perl5).
.PP
This can also be handy for locating subdir's used
for configuring packages:
.PP
.Vb 1
\&    use FindBin::libs qw( export base=config subonly=mypackage );
.Ve
.PP
Will leave \f(CW@config\fR with any \*(L"mypacakge\*(R" holding
any \*(L"mypackage\*(R" subdir's.
.PP
\fISetting \s-1PERL5LIB:\s0 p5lib\fR
.IX Subsection "Setting PERL5LIB: p5lib"
.PP
For cases where the environment is more useful for setting
up library paths \*(L"p5lib\*(R" can be used to preload this variable.
This is mainly useful for automatically including directories
outside of the parent tree of \f(CW$FindBin::bin\fR.
.PP
For example, using:
.PP
.Vb 1
\&    $ export PERL5LIB="/usr/local/foo:/usr/local/bar";
\&
\&    $ myprog;
.Ve
.PP
or simply
.PP
.Vb 1
\&    $ PERL5LIB="/usr/local/lib/foo:/usr/lib/bar" myprog;
.Ve
.PP
(depending on your shell) with #! code including:
.PP
.Vb 1
\&    use FindBin::libs qw( p5lib );
.Ve
.PP
will not \*(L"use lib\*(R" any dir's found but will update \s-1PERL5LIB\s0
to something like:
.PP
.Vb 1
\&    /home/me/sandbox/branches/lib:/usr/local/lib/foo:/usr/lib/bar
.Ve
.PP
This can make controlling the paths used simpler and avoid
the use of symlinks for some testing (see examples below).
.PP
Note that \*(L"p5lib\*(R" and \*(L"nouse\*(R" are proably worth
.SS "Skipping directories"
.IX Subsection "Skipping directories"
By default, lib directories under / and /usr are
sliently ignored. This normally means that /lib, /usr/lib, and
\&'/usr/local/lib' are skipped. The \*(L"ignore\*(R" parameter provides
a comma-separated list of directories to ignore:
.PP
.Vb 1
\&    use FindBin::libs qw( ignore=/skip/this,/and/this/also );
.Ve
.PP
will replace the standard list and thus skip \*(L"/skip/this/lib\*(R"
and \*(L"/and/this/also/lib\*(R". It will search \*(L"/lib\*(R" and \*(L"/usr/lib\*(R"
since the argument ignore list replaces the original one.
.SS "Homegrown Library Management"
.IX Subsection "Homegrown Library Management"
An all-too-common occurrance managing perly projects is
being unable to install new modules becuse \*(L"it might 
break things\*(R", and being unable to test them because
you can't install them. The usual outcome of this is a 
collection of hard-coded
.PP
.Vb 1
\&    use lib qw( /usr/local/projectX ... )
.Ve
.PP
code at the top of each #! file that has to be updated by
hand for each new project.
.PP
To get away from this you'll often see relative paths
for the lib's, which require running the code from one
specific place. All this does is push the hard-coding
into cron, shell wrappers, and begin blocks.
.PP
With FindBin::libs you need suffer no more.
.PP
Automatically finding libraries in and above the executable
means you can put your modules into cvs/svn and check them
out with the project, have multiple copies shared by developers,
or easily move a module up the directory tree in a testbed
to regression test the module with existing code. All without
having to modify a single line of code.
.IP "Code-speicfic modules." 4
.IX Item "Code-speicfic modules."
Say your sandbox is in ./sandbox and you are currently
working in ./sandbox/projects/package/bin on a perl
executable. You may have some number of modules that
are specific \*(-- or customized \*(-- for this pacakge, 
share some modules within the project, and may want 
to use company-wide modules that are managed out of 
\&./sandbox in development. All of this lives under a 
\&./qc tree on the test boxes and under ./production 
on production servers.
.Sp
For simplicity, say that your sandbox lives in your
home direcotry, /home/jowbloe, as a directory or a
symlink.
.Sp
If your #! uses FindBin::libs in it then it will
effectively
.Sp
.Vb 6
\&    use lib
\&    qw(
\&        /home/jowbloe/sandbox/lib
\&        /home/jowbloe/sandbox/project/lib
\&        /home/jowbloe/sandbox/project/package/lib
\&    );
.Ve
.Sp
if you run /home/jowbloe/sandbox/project/package/bin/foobar.
This will happen the same way if you use a relative or
absolute path, perl \-d the thing, or if any of the lib
directories are symlinks outside of your sandbox.
.Sp
This means that the most specific module directories
(\*(L"closest\*(R" to your executable) will be picked up first.
.Sp
If you have a version of Frobnicate.pm in your ./package/lib
for modifications fine: you'll use it before the one in 
\&./project or ./sandbox.
.Sp
Using the \*(L"p5lib\*(R" argument can help in case where some of 
the code lives outside of the sandbox. To test a sandbox
version of some other module:
.Sp
.Vb 1
\&    use FindBin::libs qw( p5lib );
.Ve
.Sp
and
.Sp
.Vb 1
\&    $ PERL5LIB=/other/sandbox/module foobar;
.Ve
.IP "Regression Testing" 4
.IX Item "Regression Testing"
Everntually, however, you'll need to regression test 
Frobnicate.pm with other modules.
.Sp
Fine: move, copy, or symlink it into ./project/lib and
you can merrily run ./project/*/bin/* with it and see 
if there are any problems. In fact, so can the nice 
folks in \s-1QC\s0.
.Sp
If you want to install and test a new module just 
prefix it into, say, ./sandbox/lib and all the code
that has FindBin::libs will simply use it first.
.IP "Testing with Symlinks" 4
.IX Item "Testing with Symlinks"
\&\f(CW$FindBin::Bin\fR is relative to where an executable is started from.
This allows a symlink to change the location of directories used
by FindBin::libs. Full regression testing of an executable can be
accomplished with a symlink:
.Sp
.Vb 3
\&    ./sandbox
\&        ./lib \-> /homegrown/dir/lib
\&        ./lib/What/Ever.pm
\&
\&        ./pre\-change
\&            ./bin/foobar
\&
\&        ./post\-change
\&            ./lib/What/Ever.pm
\&            ./bin/foobar \-> ../../pre\-last\-change/bin/foobar
.Ve
.Sp
Running foobar symlinked into the post-change directory will
test it with whatever collection of modules is in the post-change
directory. A large regression test on some collection of 
changed modules can be performed with a few symlinks into a 
sandbox area.
.IP "Managing Configuration and Meta-data Files" 4
.IX Item "Managing Configuration and Meta-data Files"
The \*(L"base\*(R" option alters FindBin::libs standard base directory.
This allows for a heirarchical set of metadata directories:
.Sp
.Vb 4
\&    ./sandbox
\&        ./meta
\&        ./project/
\&            ./meta
\&
\&        ./project/package
\&            ./bin
\&            ./meta
.Ve
.Sp
with
.Sp
.Vb 1
\&    use FindBin::libs qw( base=meta export );
\&
\&    sub read_meta
\&    {
\&        my $base = shift;
\&
\&        for my $dir ( @meta )
\&        {
\&            # open the first one and return
\&            ...
\&        }
\&
\&        # caller gets back empty list if nothing was read.
\&
\&        ()
\&    }
.Ve
.ie n .IP "using ""prove"" with local modules." 4
.el .IP "using ``prove'' with local modules." 4
.IX Item "using prove with local modules."
Modules that are not intended for \s-1CPAN\s0 will not usually have
a Makefile.PL or Build setup. This makes it harder to check
the code via \*(L"make test\*(R". Instead of hacking a one-time 
Makefile, FindBin::libs can be used to locate modules in 
a \*(L"lib\*(R" directory adjacent to the "t: directory. The setup
for this module would look like:
.Sp
.Vb 3
\&    ./t/01.t
\&    ./t/02.t
\&    ...
\&
\&    ./lib/FindBin/libs.pm
.Ve
.Sp
since the *.t files use FindBin::libs they can locate the 
most recent version of code without it having to be copied
into a ./blib directory (usually via make) before being
processed. If the module did not have a Makefile this would
allow:
.Sp
.Vb 1
\&    prove t/*.t;
.Ve
.Sp
to check the code.
.SH "Notes"
.IX Header "Notes"
.SS "Alternatives"
.IX Subsection "Alternatives"
FindBin::libs was developed to avoid pitfalls with
the items listed below. As of FindBin::libs\-1.20,
this is also mutli-platform, where other techniques
may be limited to *NIX or at least less portable.
.IP "\s-1PERL5LIBS\s0" 4
.IX Item "PERL5LIBS"
\&\s-1PERL5LIB\s0 can be used to accomplish the same directory
lookups as FindBin::libs.  The problem is \s-1PERL5LIB\s0 often
contains absolte paths and does not automatically change
depending on where tests are run. This can leave you 
modifying a file, changing directory to see if it works
with some other code and testing an unmodified version of 
the code via \s-1PERL5LIB\s0. FindBin::libs avoids this by using
\&\f(CW$FindBin::bin\fR to reference where the code is running from.
.Sp
The same is true of trying to use almost any environmental
solution, with Perl's built in mechanism or one based on
\&\f(CW$ENV\fR{ \s-1PWD\s0 } or qx( pwd ).
.Sp
Aside: Combining an existing \s-1PERL5LIB\s0 for 
out-of-tree lookups with the \*(L"p5lib\*(R" option 
works well for most development situations.
.IP "use lib qw( ../../../../Lib );" 4
.IX Item "use lib qw( ../../../../Lib );"
This works, but how many dots do you need to get all
the working lib's into a module or #! code? Class
distrubuted among several levels subdirectories may
have qw( ../../../lib ) vs. qw( ../../../../lib )
or various combinations of them. Validating these by
hand (let alone correcting them) leaves me crosseyed
after only a short session.
.IP "Anchor on a fixed lib directory." 4
.IX Item "Anchor on a fixed lib directory."
Given a standard directory, it is possible to use
something like:
.Sp
.Vb 3
\&    BEGIN
\&    {
\&        my ( $libdir ) = $0 =~ m{ ^( .+? )/SOMEDIR/ }x;
\&
\&        eval "use lib qw( $libdir )";
\&    }
.Ve
.Sp
This looks for a standard location (e.g., /path/to/Mylib)
in the executable path (or cwd) and uses that.
.Sp
The main problem here is that if the anchor ever changes
(e.g., when moving code between projects or relocating 
directories now that \s-1SVN\s0 supports it) the path often has
to change in multiple files. The regex also may have to
support multiple platforms, or be broken into more complicated
File::Spec code that probably looks pretty much like what
.Sp
.Vb 1
\&    use FindBin::libs qw( base=Mylib )
.Ve
.Sp
does anyway.
.SS "FindBin::libs\-1.2+ uses File::Spec"
.IX Subsection "FindBin::libs-1.2+ uses File::Spec"
In order to accmodate a wider range of filesystems, 
the code has been re-written to use File::Spec for
all directory and volume manglement.
.PP
There is one thing that File::Spec does not handle,
hoever, which is fully reolving absolute paths. That
still has to be handled via abs_path, when it works.
.PP
The issue is that File::Spec::rel2abs and 
Cwd::abs_path work differently: abs_path only 
returns true for existing directories and 
resolves symlinks; rel2abs simply prepends \fIcwd()\fR 
to any non-absolute paths.
.PP
The difference for FinBin::libs is that 
including redundant directories can lead to 
unexpected results in what gets included; 
looking up the contents of heavily-symlinked 
paths is slow (and has some \*(-- admittedly 
unlikely \*(-- failures at runtime). So, \fIabs_path()\fR 
is the preferred way to find where the lib's 
really live after they are found looking up the 
tree. Using \fIabs_path()\fR also avoids problems 
where the same directory is included twice in a 
sandbox' tree via symlinks.
.PP
Due to previous complaints that abs_path did not 
work properly on all systems, the current 
version of FindBin::libs uses File::Spec to 
break apart and re-assemble directories, with 
abs_path used optinally. If \*(L"abs_path cwd\*(R" works 
then abs_path is used on the directory paths 
handed by \fIFile::Spec::catpath()\fR; otherwise the 
paths are used as-is. This may leave users on 
systms with non-working \fIabs_path()\fR having extra
copies of external library directories in \f(CW@INC\fR.
.PP
Another issue is that I've heard reports of 
some systems failing the '\-d' test on symlinks,
where '\-e' would have succeded.
.SH "See Also"
.IX Header "See Also"
.IP "File::Spec" 4
.IX Item "File::Spec"
This is used for portability in dis\- and re-assembling 
directory paths based on \f(CW$FindBin::Bin\fR.
.IP "Older code." 4
.IX Item "Older code."
FindBin::libs_5_8.pm is installed if $^V indicates
that the running perl is prior to v5.10.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
In order to avoid including junk, FindBin::libs
uses '\-d' to test the items before including
them on the library list. This works fine so 
long as \fIabs_path()\fR is used to disambiguate any
symlinks first. If \fIabs_path()\fR is turned off
then legitimate directories may be left off in
whatever local conditions might cause a valid
symlink to fail the '\-d' test."
.IP "\(bu" 4
File::Spec 3.16 and prior have a bug in \s-1VMS\s0 of
not returning an absolute paths in splitdir for
dir's without a leading '.'. Fix for this is to
unshift '', \f(CW@dirpath\fR if \f(CW$dirpath\fR[0]. While not a
bug, this is obviously a somewhat kludgy workaround
and should be removed (with an added test for a 
working version) once the File::Spec is fixed.
.IP "\(bu" 4
The hack for prior\-to\-5.12 versions of perl is 
messy, but is the only I've found that works for
the moment on *NIX, \s-1VMS\s0, and \s-1MSW\s0. I am not sure
whether any of these systems are normally configured
to share perl modules between versions. If the 
moduels are not shared on multiple platforms then
I can make this work by managing the installation
rather than checking this every time at startup.
.Sp
For the moment, at least, this seems to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steven Lembark, Workhorse Computing <lembark@wrkhors.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003\-2012, Steven Lembark, Workhorse Computing.
This code is released under the same terms as Perl\-5.10
or any later version of Perl.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 780:" 4
.IX Item "Around line 780:"
You forgot a '=back' before '=head1'
.IP "Around line 789:" 4
.IX Item "Around line 789:"
\&'=item' outside of any '=over'
.IP "Around line 844:" 4
.IX Item "Around line 844:"
You forgot a '=back' before '=head2'
.IP "Around line 941:" 4
.IX Item "Around line 941:"
You forgot a '=back' before '=head1'
